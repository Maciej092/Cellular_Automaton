import numpy as np
from copy import deepcopy as dp


class CellularAutomata:
    def __init__(self, number_of_grains, space_width, space_length, border_rule, string):
        self.MOORE = ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1))
        self.VONNEUMANN = ((-1, 0), (0, -1), (0, 1), (1, 0))
        self.HEXAGONAL_LEFT = ((-1, -1), (-1, 0), (0, -1), (0, 1), (1, 0), (1, 1))
        self.HEXAGONAL_RIGHT = ((-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0))
        self.PENTAGONAL_LEFT = ((-1, -1), (-1, 0), (0, -1), (1, -1), (1, 0))
        self.PENTAGONAL_RIGHT = ((-1, 0), (-1, 1), (0, 1), (1, 0), (1, 1))
        self.border_rule = border_rule                     # Border rule is entered from the gui
        self.number_of_grains = number_of_grains           # Number of random seeds generated by add_random func.
        self.number_of_reserved_ids = 1
        self.space_width = space_width                     # Variable used to specify the size of CA space
        self.space_length = space_length                   # Currently this var is useless
        self.space = np.zeros((self.space_width, self.space_width), dtype=np.uint8)    # Main space of CA algorithm
        self.space_prev = np.zeros((self.space_width, self.space_width), dtype=np.uint8)
        self.space_clear = np.zeros((self.space_width, self.space_width))    # Clear space. Used in the gui
        self.cell_empty = 0
        self.neighbours = self.choose_neighbours(string)
        self.color_id = list()                                # List of RGB colors. Generation is executed in add_random func.
        self.list_of_id = set()                               # Set of the IDs ( integer values ): for deleting reason

    @staticmethod
    def evaluate_id(nei_list):                                # Choose the id which is the most frequent in neighbourhood
        counter = 0
        num = nei_list[0]
        for i in nei_list:
            if i > 0:
                curr_frequency = nei_list.count(i)
                if curr_frequency > counter:
                    counter = curr_frequency
                    num = i
        return int(num)

    def choose_neighbours(self, string):  # Choose the neighbourhood method
        if 'MOORE' == string:
            neighbours = self.MOORE
        elif 'VONNEUMANN' == string:
            neighbours = self.VONNEUMANN
        elif 'HEXAGONAL_LEFT' == string:
            neighbours = self.HEXAGONAL_LEFT
        elif 'HEXAGONAL_RIGHT' == string:
            neighbours = self.HEXAGONAL_RIGHT
        elif 'PENTAGONAL_LEFT' == string:
            neighbours = self.PENTAGONAL_LEFT
        elif 'PENTAGONAL_RIGHT' == string:
            neighbours = self.PENTAGONAL_RIGHT
        else:
            neighbours = self.VONNEUMANN
        return neighbours

    def add_random(self):
        self.color_id.append(np.array([255, 255, 255]))    # White color - reserved/ blank space
        for i in range(self.number_of_grains):
            color = np.random.randint(0, 230, 3)           # Generate the list of random RGB colors
            self.color_id.append(color)
        for i in range(self.number_of_grains):
            random_x = np.random.randint(self.space_width - 1)
            random_y = np.random.randint(self.space_width - 1)
            random_id = np.random.randint(self.number_of_reserved_ids, self.number_of_grains + self.number_of_reserved_ids)
            self.space[random_x, random_y] = random_id
            self.list_of_id.add(random_id)
        return self.color_id

    def one_step(self):                                    # One cellular automaton step
        self.space_prev = dp(self.space)
        for x in range(self.space_width):
            for y in range(self.space_width):
                if self.space_prev[x, y] == self.cell_empty:
                    nei_list = list()
                    for neigh in self.neighbours:
                        xn, yn = neigh
                        if 'ABSORBING' == self.border_rule:
                            if (x + xn) < 0 or (y + yn) < 0 or (x + xn) >= self.space_width or (y + yn) >= self.space_width:
                                nei_list.append(0)
                            else:
                                nei_list.append(self.space_prev[x+xn, y+yn])
                        else:
                            nei_list.append(self.space_prev[(x + xn) % self.space_width, (y + yn) % self.space_width])
                    if sum(nei_list) > 0:
                        self.space[x, y] = self.evaluate_id(nei_list)
                    else:
                        self.space[x, y] = 0
                else:
                    continue
        return self.space

